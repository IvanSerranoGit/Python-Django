Qu√© son los tipos de datos
En cualquier lenguaje de programaci√≥n de alto nivel se manejan tipos de datos. Los tipos de datos definen un conjunto de valores que tienen una serie de caracter√≠sticas y propiedades determinadas.

Pensemos por un momento cuando √©ramos j√≥venes üôÑ y est√°bamos en el colegio en clase de matem√°ticas. Seguro que diste alguna clase en la que te ense√±aban los distintos conjuntos de n√∫meros. Los naturales (1, 2, 3, 4, ‚Ä¶), los enteros (‚Ä¶, -2, -1, 0, 1, 2, ‚Ä¶), los reales (‚Ä¶ -1.1, -0.3, 2.1, ‚Ä¶), etc. Pues bien, en programaci√≥n (y por supuesto en Python), cada uno de esos conjuntos ser√≠a lo que llamamos tipo de datos.

En Python, todo valor que pueda ser asignado a una variable tiene asociado un tipo de dato. Como ya te he mencionado alguna vez, en Python todo es un objeto. As√≠ que los tipos de datos ser√≠an las clases (donde se definen las propiedades y qu√© se puede hacer con ellas) y las variables ser√≠an las instancias (objetos) de los tipos de datos. No te preocupes si no entiendes qu√© es una clase o un objeto, lo veremos en otro tutorial.

En definitiva, un tipo de dato establece qu√© valores puede tomar una variable y qu√© operaciones se pueden realizar sobre la misma.

Tipos de datos b√°sicos de Python
¬øQu√© tipos de datos trae consigo Python?

En Python podemos encontrar distintos tipos de datos con diferentes caracter√≠sticas y clasificaciones. En este tutorial repasaremos los tipos de datos b√°sicos, aunque te introducir√© otros tipos de datos que veremos en tutoriales posteriores.

Los tipos de datos b√°sicos de Python son los booleanos, los num√©ricos (enteros, punto flotante y complejos) y las cadenas de caracteres.

Python tambi√©n define otros tipos de datos, entre los que se encuentran:

Secuencias: Los tipos list, tuple y range
Mapas: El tipo dict
Conjuntos: El tipo set
Iteradores
Clases
Instancias
Excepciones
A su vez, los tipos anteriores se pueden agrupar de diferente manera. Por ejemplo: el tipo cadena de caracteres es una secuencia inmutable; las listas, tuplas o diccionarios, entre otros, son contenedores y colecciones, etc. Pero esto no lo veremos aqu√≠.

En fin, no te agobies con tanto tipo ni tanto concepto nuevo. T√≥matelo con calma que est√°s aprendiendo. Comencemos por lo f√°cil revisando los tipos de datos b√°sicos de Python.

Tipos num√©ricos
Python define tres tipos de datos num√©ricos b√°sicos: enteros, n√∫meros de punto flotante (simular√≠a el conjunto de los n√∫meros reales, pero ya veremos que no es as√≠ del todo) y los n√∫meros complejos.

N√∫meros enteros
El tipo de los n√∫meros enteros es int. Este tipo de dato comprende el conjunto de todos los n√∫meros enteros, pero como dicho conjunto es infinito, en Python el conjunto est√° limitado realmente por la capacidad de la memoria disponible. No hay un l√≠mite de representaci√≥n impuesto por el lenguaje.

Pero tranquilidad, que para el 99% de los programas que desarrolles tendr√°s suficiente con el subconjunto que puedes representar.

Un n√∫mero de tipo int se crea a partir de un literal que represente un n√∫mero entero o bien como resultado de una expresi√≥n o una llamada a una funci√≥n.

Ejemplos:

>>> a = -1  # a es de tipo int y su valor es -1
>>> b = a + 2  # b es de tipo int y su valor es 1
>>> print(b)
1
Tambi√©n podemos representar los n√∫meros enteros en formato binario, octal o hexadecimal.

Los n√∫meros octales se crean anteponiendo 0o a una secuencia de d√≠gitos octales (del 0 al 7).

Para crear un n√∫mero entero en hexadecimal, hay que anteponer 0x a una secuencia de d√≠gitos en hexadecimal (del 0 al 9 y de la A la F).

En cuanto a los n√∫meros en binario, se antepone 0b a una secuencia de d√≠gitos en binario (0 y 1).

>>> diez = 10
>>> diez_binario = 0b1010
>>> diez_octal = 0o12
>>> diez_hex = 0xa
>>> print(diez)
10
>>> print(diez_binario)
10
>>> print(diez_octal)
10
>>> print(diez_hex)
10
N√∫meros de punto flotante
Bueno, bueno, bueno, entramos en tema caliente y no s√© muy bien c√≥mo explicar esto para que sea f√°cil de entender.

¬øRecuerdas que te dije que los n√∫meros de punto flotante representaban, m√°s o menos, al conjunto de los n√∫meros reales?

Vamos a hacer un experimento que te va a dejar a cuadros. Abre un terminal y ejecuta el comando python3 para lanzar el int√©rprete de Python. A continuaci√≥n introduce la expresi√≥n 1.1 + 2.2 y mira cu√°l es el resultado.

>>> 1.1 + 2.2
3.3000000000000003
üò≥ ¬øEn serio? üò≥ ¬øQu√© es ese 3 del final?

Representaci√≥n de los n√∫meros de punto flotante
Tenemos que repasar un poco de teor√≠a que voy a tratar de simplificar porque la explicaci√≥n completa da para un art√≠culo entero.

Al igual que ocurre con los n√∫meros enteros, los n√∫meros reales son infinitos y, por tanto, es imposible representar todo el conjunto de n√∫meros reales con un ordenador.

Para representar el mayor n√∫mero posible de los n√∫meros reales con las limitaciones de memoria (tama√±os de palabra de 32 y 64 bits), se adapt√≥ la notaci√≥n cient√≠fica de representaci√≥n de n√∫meros reales al sistema binario (que es el sistema que se utiliza en programaci√≥n para representar los datos e instrucciones).

En esta notaci√≥n cient√≠fica, los n√∫meros se representan as√≠:

N√∫mero	Notaci√≥n cient√≠fica
101,1	1,011 * 102
0,032	3,2 * 10-2
Vaya tela, ¬øno? Pero es una muy buena soluci√≥n que ha llegado hasta nuestros d√≠as.

El caso es que la suma de la representaci√≥n en punto flotante en binario del n√∫mero 1,1 y de la representaci√≥n en punto flotante en binario del n√∫mero 2,2, dan como resultado 3,3000000000000003

Pero hay m√°s casos, como por ejemplo la representaci√≥n del n√∫mero 1/3. En alg√∫n momento, el ordenador tiene que truncar el n√∫mero peri√≥dico resultante.

La explicaci√≥n final es que los n√∫meros de punto flotante se representan en el hardware del ordenador como fracciones de base 2 (binarias). Y el problema est√° en que la mayor√≠a de las fracciones decimales no se pueden representar de forma exacta como fracciones binarias porque tienen infinitos n√∫meros decimales. Una consecuencia es que, en general, los n√∫meros decimales de punto flotante que usas en tus aplicaciones son una aproximaci√≥n de los n√∫meros binarios de punto flotante realmente almacenados en la m√°quina.

N√∫meros de Punto flotante en Python
Pues una vez vista esta simplificada introducci√≥n a los n√∫meros de punto flotante, te dir√© que este tipo de datos en Python es float.

Puedes usar el tipo float sin problemas para representar cualquier n√∫mero real (siempre teniendo en cuenta que es una aproximaci√≥n lo m√°s precisa posible). Por tanto para longitudes, pesos, frecuencias, ‚Ä¶, en los que pr√°cticamente es lo mismo 3,3 que 3,3000000000000003 el tipo float es el m√°s apropiado.

Cuando un n√∫mero float vaya a ser usado por una persona, en lugar de por el ordenador, puedes darle formato al n√∫mero de la siguiente manera:

>>> real = 1.1 + 2.2  # real es un float
>>> print(real)
3.3000000000000003  # Representaci√≥n aproximada de 3.3
>>> print(f'{real:.2f}')
3.30  # real mostrando √∫nicamente 2 cifras decimales
Al igual que los n√∫meros enteros, un float se crea a partir de un literal, o bien como resultado de una expresi√≥n o una funci√≥n.

>>> un_real = 1.1  # El literal debe incluir el car√°cter .
>>> otro_real = 1/2  # El resultado de 1/2 es un float
>>> not_cient = 1.23E3  # float con notaci√≥n cient√≠fica (1230.0)
Y para terminar esta secci√≥n, te adelanto que, si por cualquier motivo s√≠ que necesitas una mayor precisi√≥n a la hora de trabajar con los n√∫meros reales, Python tiene otros tipos de datos, como Decimal.

El tipo Decimal es ideal a la hora de trabajar, por ejemplo, con dinero o tipos de inter√©s. Este tipo de dato trunca la parte decimal del n√∫mero para ser m√°s preciso, pero no es el objetivo de este tutorial hablar sobre el tipo de dato Decimal.

N√∫meros complejos
El √∫ltimo tipo de dato num√©rico b√°sico que tiene Python es el de los n√∫meros complejos, complex.

Los n√∫meros complejos tienen una parte real y otra imaginaria y cada una de ellas se representa como un float.

Para crear un n√∫mero complejo, se sigue la siguiente estructura <parte_real>+<parte_imaginaria>j. Y se puede acceder a la parte real e imaginaria a trav√©s de los atributos real e imag:

>>> complejo = 1+2j
>>> complejo.real
1.0
>>> complejo.imag
2.0
Aritm√©tica de los tipos num√©ricos
Con todos los tipos num√©ricos se pueden aplicar las operaciones de la aritm√©tica: suma, resta, producto, divisi√≥n, ‚Ä¶

En Python est√° permitido realizar una operaci√≥n aritm√©tica con n√∫meros de distinto tipo. En este caso, el tipo num√©rico ¬´m√°s peque√±o¬ª se convierte al del tipo ¬´m√°s grande¬ª, de manera que el tipo del resultado siempre es el del tipo mayor. Entendemos que el tipo int es menor que el tipo float que a su vez es menor que el tipo complex.

Por tanto, es posible, por ejemplo, sumar un int y un float:

>>> 1 + 2.0
3.0
>>> 2+3j + 5.7
(7.7+3j)
Tipo booleano
En Python la clase que representa los valores booleanos es bool. Esta clase solo se puede instanciar con dos valores/objetos: True para representar verdadero y False para representar falso.

Una particularidad del lenguaje es que cualquier objeto puede ser usado en un contexto donde se requiera comprobar si algo es verdadero o falso. Por tanto, cualquier objeto se puede usar en la condici√≥n de un if o un while (son estructuras de control que veremos en tutoriales posteriores) o como operando de una operaci√≥n booleana.

Por defecto, cualquier objeto es considerado como verdadero con dos excepciones:

Que implemente el m√©todo __bool__() y este devuelva False.
Que implem√©nte el m√©todo __len__() y este devuelva 0.
Adem√°s, los siguientes objetos/instancias tambi√©n son consideradas falsas:

None
False
El valor cero de cualquier tipo num√©rico: 0, 0.0, 0j, ‚Ä¶
Secuencias y colecciones vac√≠as (veremos estos tipos en otros tutoriales): '', (), [], {}, set(), range(0)
Tipo cadena de caracteres
Una vez que hemos acabado con los n√∫meros, es el turno de las letras üòú

Otro tipo b√°sico de Python, e imprescindible, son las secuencias o cadenas de caracteres. Este tipo es conocido como string aunque su clase verdadera es str.

Formalmente, un string es una secuencia inmutable de caracteres en formato Unicode.

Para crear un string, simplemente tienes que encerrar entre comillas simples '' o dobles "" una secuencia de caracteres.

Se puede usar indistintamente comillas simples o dobles, con una particularidad. Si en la cadena de caracteres se necesita usar una comilla simple, tienes dos opciones: usar comillas dobles para encerrar el string, o bien, usar comillas simples pero anteponer el car√°cter \ a la comilla simple del interior de la cadena. El caso contrario es similar.

Veamos todo esto con un ejemplo:

>>> hola = 'Hola "Pythonista"'
>>> hola_2 = 'Hola \'Pythonista\''
>>> hola_3 = "Hola 'Pythonista'"
>>> print(hola)
Hola "Pythonista"
>>> print(hola_2)
Hola 'Pythonista'
>>> print(hola_3)
Hola 'Pythonista'
A diferencia de otros lenguajes, en Python no existe el tipo ¬´car√°cter¬ª. No obstante, se puede simular con un string de un solo car√°cter:

>>> caracter_a = 'a'
>>> print(caracter_a)
a
Revisa este tutorial si quieres conocer m√°s sobre la clase str de Python.

Otros tipos
Hasta aqu√≠ hemos repasado los tipos de datos b√°sicos de Python, sin embargo, el lenguaje ofrece muchos tipos m√°s. Te hago aqu√≠ un avance de los m√°s importantes, aunque los veremos en detalle en otros tutoriales.

Adem√°s de los tipos b√°sicos, otros tipos fundamentales de Python son las secuencias (list y tuple), los conjuntos (set) y los mapas (dict).

Todos ellos son tipos compuestos y se utilizan para agrupar juntos varios valores.

Las listas son secuencias mutables de valores.
Las tuplas son secuencias inmutables de valores.
Los conjuntos se utilizan para representar conjuntos √∫nicos de elementos, es decir, en un conjunto no pueden existir dos objetos iguales.
Los diccionarios son tipos especiales de contenedores en los que se puede acceder a sus elementos a partir de una clave √∫nica.
>>> lista = [1, 2, 3, 8, 9]
>>> tupla = (1, 4, 8, 0, 5)
>>> conjunto = set([1, 3, 1, 4])
>>> diccionario = {'a': 1, 'b': 3, 'z': 8}
>>> print(lista)
[1, 2, 3, 8, 9]
>>> print(tupla)
(1, 4, 8, 0, 5)
>>> print(conjunto)
{1, 3, 4}
>>> print(diccionario)
{'a': 1, 'b': 3, 'z': 8}
Conocer el tipo de una variable
Ahora te voy a presentar dos funciones para que puedas jugar con todo lo que hemos visto en este tutorial. Son type() e isinstance():

type() recibe como par√°metro un objeto y te devuelve el tipo del mismo.
isinstance() recibe dos par√°metros: un objeto y un tipo. Devuelve True si el objeto es del tipo que se pasa como par√°metro y False en caso contrario.
>>> type(3)
<class 'int'>
>>> type(2.78)
<class 'float'>
>>> type('Hola')
<class 'str'>
>>> isinstance(3, float)
False
>>> isinstance(3, int)
True
>>> isinstance(3, bool)
False
>>> isinstance(False, bool)
True
Conversi√≥n de tipos
Lo √∫ltimo que veremos en este tutorial sobre tipos de datos es la conversi√≥n de tipos.

¬øEsto qu√© significa?

Imagina que tienes una variable edad de tipo string cuyo valor es '25'. Se podr√≠a decir que edad, aunque realmente es una cadena de caracteres, contiene un n√∫mero. Sin embargo, si intentas sumar 10 a edad, el int√©rprete te dar√° un error porque edad es de tipo str y 10 un tipo num√©rico.

>>> edad = '25'
>>> edad = edad + 10
Traceback (most recent call last):
  File "<input>", line 1, in <module>
TypeError: can only concatenate str (not "int") to str
¬øC√≥mo puedo tratar la variable edad como un n√∫mero? Convirti√©ndola a un tipo num√©rico, por ejemplo, al tipo int.

Para ello, Python ofrece las siguientes funciones:

str(): Devuelve la representaci√≥n en cadena de caracteres del objeto que se pasa como par√°metro.
int(): Devuelve un int a partir de un n√∫mero o secuencia de caracteres.
float(): Devuelve un float a partir de un n√∫mero o secuencia de caracteres.
complex(): Devuelve un complex a partir de un n√∫mero o secuencia de caracteres.
Si a las funciones anteriores se les pasa como par√°metro un valor inv√°lido, el int√©rprete mostrar√° un error.

>>> edad = int(edad) + 10  # Convierte edad a int
>>> edad  #  edad es un int
35
>>> edad = str(edad)  # Convierte edad a str
>>> edad  # edad es un str (se muestran las '')
'35'
>>> float('18.66')  # Convierte un str a float
18.66
>>> float('hola')  # Convierte un str a float (pero no es v√°lido)
Traceback (most recent call last):
  File "<input>", line 1, in <module>
ValueError: could not convert string to float: 'hola'
Bueno, espero que hayas disfrutado este tutorial tanto como yo lo he hecho escribi√©ndolo. No te pierdas el siguiente ya que es la continuaci√≥n de este. En √©l veremos los operadores de Python para llevar a cabo operaciones sobre los distintos tipos de datos.
